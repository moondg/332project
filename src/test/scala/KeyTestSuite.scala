import Core.Key._
import Core.Key
import Core.Block._

import scala.io.Source

import org.scalacheck._
import Prop.forAll

object KeyTest extends Properties("Key") {
  val inputFile = "src/test/resources/binary"
  val block = blockFromFile(inputFile)
  val answer = List(
    Array(0x4a, 0x69, 0x6d, 0x47, 0x72, 0x61, 0x79, 0x52, 0x49, 0x50),
    Array(0x95, 0xe0, 0xe4, 0x82, 0x62, 0xb3, 0xed, 0xfe, 0x04, 0x47),
    Array(0x45, 0x97, 0x93, 0x53, 0xdb, 0xed, 0x53, 0x29, 0x36, 0x5c),
    Array(0x88, 0x2a, 0x02, 0xc3, 0x15, 0x36, 0x2b, 0x60, 0x76, 0x5f),
    Array(0x5c, 0x90, 0xab, 0x38, 0xae, 0x52, 0x89, 0x62, 0x15, 0xd7),
    Array(0x72, 0xdc, 0x0c, 0xa5, 0x1e, 0x33, 0x3f, 0x32, 0x4b, 0x7a),
    Array(0x10, 0x43, 0x1a, 0xf6, 0xa0, 0xd8, 0x47, 0xb8, 0xc5, 0x5f),
    Array(0x5e, 0xfc, 0x4a, 0xbf, 0xac, 0xa2, 0x3e, 0x8c, 0xa8, 0xed),
    Array(0x44, 0xf7, 0x8c, 0x8b, 0x40, 0xbf, 0x1c, 0xe1, 0x9a, 0x82),
    Array(0x84, 0xc0, 0x99, 0x2f, 0x3b, 0x94, 0xfd, 0x25, 0xac, 0xb0))
    .map(k => k.map(_.toByte))

  def same(a: Array[Byte], b: Array[Byte]): Boolean = {
    a.zip(b).foldLeft(true) { case (acc, (x, y)) => acc && (x == y) }
  }
  def same(a: Key, b: Key): Boolean = { same(a.key, b.key) }

  property("Key parsing") = {
    Prop.all(block.block.map(_.key.key).zip(answer).map { case (a, b) =>
      Prop { same(a, b) }
    }: _*)
  }

  val small = List(
    Array(0x4a, 0x69, 0x6d, 0x47, 0x72, 0x61, 0x79, 0x52, 0x49, 0x4f),
    Array(0x95, 0xe0, 0xe4, 0x82, 0x62, 0xb3, 0xed, 0xfe, 0x04, 0x46),
    Array(0x45, 0x97, 0x93, 0x53, 0xdb, 0xed, 0x53, 0x29, 0x36, 0x5b),
    Array(0x88, 0x2a, 0x02, 0xc3, 0x15, 0x36, 0x2b, 0x60, 0x76, 0x5e),
    Array(0x5c, 0x90, 0xab, 0x38, 0xae, 0x52, 0x89, 0x62, 0x15, 0xd6),
    Array(0x72, 0xdc, 0x0c, 0xa5, 0x1e, 0x33, 0x3f, 0x32, 0x4b, 0x79),
    Array(0x10, 0x43, 0x1a, 0xf6, 0xa0, 0xd8, 0x47, 0xb8, 0xc5, 0x5e),
    Array(0x5e, 0xfc, 0x4a, 0xbf, 0xac, 0xa2, 0x3e, 0x8c, 0xa8, 0xec),
    Array(0x44, 0xf7, 0x8c, 0x8b, 0x40, 0xbf, 0x1c, 0xe1, 0x9a, 0x81),
    Array(0x84, 0xc0, 0x99, 0x2f, 0x3b, 0x94, 0xfd, 0x25, 0xac, 0xaf))
    .map(k => new Key(k.map(_.toByte)))
  val big = List(
    Array(0x4a, 0x69, 0x6d, 0x47, 0x72, 0x61, 0x79, 0x52, 0x49, 0x51),
    Array(0x95, 0xe0, 0xe4, 0x82, 0x62, 0xb3, 0xed, 0xfe, 0x04, 0x48),
    Array(0x45, 0x97, 0x93, 0x53, 0xdb, 0xed, 0x53, 0x29, 0x36, 0x5d),
    Array(0x88, 0x2a, 0x02, 0xc3, 0x15, 0x36, 0x2b, 0x60, 0x76, 0x60),
    Array(0x5c, 0x90, 0xab, 0x38, 0xae, 0x52, 0x89, 0x62, 0x15, 0xd8),
    Array(0x72, 0xdc, 0x0c, 0xa5, 0x1e, 0x33, 0x3f, 0x32, 0x4b, 0x7b),
    Array(0x10, 0x43, 0x1a, 0xf6, 0xa0, 0xd8, 0x47, 0xb8, 0xc5, 0x60),
    Array(0x5e, 0xfc, 0x4a, 0xbf, 0xac, 0xa2, 0x3e, 0x8c, 0xa8, 0xee),
    Array(0x44, 0xf7, 0x8c, 0x8b, 0x40, 0xbf, 0x1c, 0xe1, 0x9a, 0x83),
    Array(0x84, 0xc0, 0x99, 0x2f, 0x3b, 0x94, 0xfd, 0x25, 0xac, 0xb1))
    .map(k => new Key(k.map(_.toByte)))
  property("Key prev") = {
    Prop.all(block.block.map(record => prev(record.key)).zip(small).map { case (a, b) =>
      Prop { same(a, b) }
    }: _*)
  }

  property("Key next") = {
    Prop.all(block.block.map(record => next(record.key)).zip(big).map { case (a, b) =>
      Prop { same(a, b) }
    }: _*)
  }

  val nextEdge = new Key(Array(1, 0, 0, 0, 0, 0, 0, 0, 0, 0))
  val prevEdge = new Key(Array(0, -1, -1, -1, -1, -1, -1, -1, -1, -1).map(_.toByte))
  property("Key prev edge") = {
    Prop.all({
      Seq(Prop { same(prev(nextEdge), prevEdge) })
    }: _*)
  }

  property("Key next edge") = {
    Prop.all({
      Seq(Prop { same(next(prevEdge), nextEdge) })
    }: _*)
  }
}
